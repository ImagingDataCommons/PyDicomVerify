#  binval.awk Copyright (c) 1993-2018, David A. Clunie DBA PixelMed Publishing. All rights reserved.
# create C++ headers from binary values template 

# can set these values on the command line:
#


# 970706 Change \'\\0\' to ends for HPUX awk which outputs the \

NR==1	{
	print "# Automatically generated from template - EDITS WILL BE LOST"
	print ""
	print "# Generated by binval.awk with options " role " " outname
	print ""
	print "from numpy import *"



	mode=""
	}

/^[ 	]*BinaryBitMap/ {
	name=""
	if (match($0,"BinaryBitMap=\"[^\"]*\""))
		name=substr($0,RSTART+length("BinaryBitMap=\""),
			RLENGTH-length("BinaryBitMap=\"")-1);
	mode="bitmap"
	print "def BinaryBitMapDescription_" name "(value:uint16)->str:"
	print "\tvalidmask=uint16(0)"
	print "\tost = \"\""

	}

/^[ 	]*BinaryValues/ {
	name=""
	if (match($0,"BinaryValues=\"[^\"]*\""))
		name=substr($0,RSTART+length("BinaryValues=\""),
			RLENGTH-length("BinaryValues=\"")-1);
	mode="values"

	print "def BinaryValueDescription_" name "(value:uint16)->str:"
	print "\tost = \"\""
	#print "\tswitch (value) {"
	n = 0

	}

/^[ 	]*[0-9]/ {
n++
	if (mode == "values") {
		valueline=$0
		if (!match(valueline,"[0-9][x0-9a-fA-F]*")) {
			print "Line " FNR \
				": error in value line - no code <" \
				valueline ">" >"/dev/tty"
			next
		}
		code=substr(valueline,RSTART,RLENGTH)
		valueline=substr(valueline,RSTART+RLENGTH)
		if (match(valueline,"[ 	]*=[ 	]*")) {
			meaning=substr(valueline,RSTART+RLENGTH)
			if (match(meaning,"[ 	]*,*[ 	]*$")) {
				meaning=substr(meaning,0,RSTART-1)
			}
		}
		else {
			meaning=code
		}
		
		if (n==1)
			print "\tif value == " code ":"
		else
			print "\telif value == " code ":"
		print "\t\tost += \"" meaning "\" "
		print "\t\treturn ost"
	}
	else if (mode == "bitmap") {
		valueline=$0
		if (!match(valueline,"[0-9][x0-9a-f]*")) {
			print "Line " FNR \
				": error in value line - no bit number <" \
				valueline ">" >"/dev/tty"
			next
		}
		bitnumber=substr(valueline,RSTART,RLENGTH)
		valueline=substr(valueline,RSTART+RLENGTH)

		if (match(valueline,"[ 	]*=[ 	]*")) {
			meaning=substr(valueline,RSTART+RLENGTH)
			if (match(meaning,"[ 	]*[:]")) {
				meaning=substr(meaning,0,RSTART-1)
			}
		}
		else {
			meaning=bitnumber
		}

		if (match(valueline,"[ 	]*:[ 	]*")) {
			falsevalue=substr(valueline,RSTART+RLENGTH)
			if (match(falsevalue,"[ 	]*[,]")) {
				falsevalue=substr(falsevalue,0,RSTART-1)
			}
			else {
				print "Line " FNR \
					": error in bitmap - bad false value <" \
					valueline ">" >"/dev/tty"
				falsevalue=""
			}
		}
		else {
			print "Line " FNR \
				": error in bitmap - no false value <" \
				valueline ">" >"/dev/tty"
			falsevalue=""
		}

		if (match(valueline,"[ 	]*,[ 	]*")) {
			truevalue=substr(valueline,RSTART+RLENGTH)
			if (match(truevalue,"[ 	]*(;|$)")) {
				truevalue=substr(truevalue,0,RSTART-1)
			}
			else {
				print "Line " FNR \
					": error in bitmap - bad true value <" \
					valueline ">" >"/dev/tty"
				truevalue=""
			}
		}
		else {
			print "Line " FNR \
				": error in bitmap - no true value <" \
				valueline ">" >"/dev/tty"
			truevalue=""
		}

			print "\tvalidmask = validmask | (1<<" bitnumber ")"
			print "\tbitvalue=value & uint16(1<<" bitnumber ")"
			print "\tost =+ \"" meaning "({}) \".format(\"" truevalue "\" if  bitvalue else \"" falsevalue "\")"
			
	}
	else {
		print "Line " FNR ": error - no group name" >"/dev/tty"
	}

	}

/^[ 	]*}/ {
	if ( mode == "bitmap") {
		print "\tif value & ~validmask :"
		print "\t\treturn \"\""
		print "\telse:"
		print "\t\treturn ost"
		print ""
	}
	else if ( mode == "values") {
		print "\telse:"
		print "\t\treturn \"\""
		print ""
	}

	mode=""
	}



